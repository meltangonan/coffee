<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Coffee Journal - Tests</title>
<style>
body { font-family: system-ui, sans-serif; max-width: 800px; margin: 40px auto; padding: 0 20px; }
h1 { color: #2C1810; }
.test { padding: 8px 12px; margin: 4px 0; border-radius: 4px; }
.pass { background: #d4edda; color: #155724; }
.fail { background: #f8d7da; color: #721c24; }
.summary { margin-top: 20px; padding: 16px; border-radius: 8px; font-weight: 600; }
.summary.all-pass { background: #d4edda; color: #155724; }
.summary.has-fail { background: #f8d7da; color: #721c24; }
</style>
</head>
<body>
<h1>Coffee Journal - Test Suite</h1>
<div id="results"></div>
<div id="summary"></div>

<script>
// Test utilities
const results = [];
function test(name, fn) {
  try {
    fn();
    results.push({ name, pass: true });
  } catch (e) {
    results.push({ name, pass: false, error: e.message });
  }
}
function assert(condition, message) {
  if (!condition) throw new Error(message || 'Assertion failed');
}
function assertEqual(actual, expected, message) {
  if (actual !== expected) {
    throw new Error(message || `Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);
  }
}
function assertDeepEqual(actual, expected, message) {
  if (JSON.stringify(actual) !== JSON.stringify(expected)) {
    throw new Error(message || `Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);
  }
}

// ========================================
// Helper functions (extracted from app)
// ========================================

function localDateStr(d) {
  if (!d) d = new Date();
  if (typeof d === 'string') d = new Date(d);
  return d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0') + '-' + String(d.getDate()).padStart(2, '0');
}

function isSameDay(d1, d2) {
  const a = new Date(d1), b = new Date(d2);
  return a.getFullYear() === b.getFullYear() && a.getMonth() === b.getMonth() && a.getDate() === b.getDate();
}

function addDays(date, days) {
  const d = new Date(date);
  d.setDate(d.getDate() + days);
  return d;
}

function daysBetween(d1, d2) {
  return Math.floor((new Date(d2) - new Date(d1)) / 86400000);
}

function normalizeRating(r) {
  if (r == null) return null;
  if (r === 'bad' || r === 'okay' || r === 'great' || r === 'perfect') return r;
  if (typeof r === 'number') {
    if (r <= 2) return 'bad';
    if (r === 3) return 'okay';
    if (r === 4) return 'great';
    return 'perfect';
  }
  return null;
}

// Freshness thresholds (should be constants)
const FRESHNESS_RESTING_DAYS = 7;
const FRESHNESS_OPTIMAL_DAYS = 21;

function getFreshness(bean) {
  if (!bean || !bean.roastDate) return { status: 'unknown', label: 'No roast date', detail: '' };
  const days = daysBetween(bean.roastDate, new Date());
  if (days < FRESHNESS_RESTING_DAYS) {
    return { status: 'resting', label: 'Resting', detail: `${FRESHNESS_RESTING_DAYS - days} days until peak` };
  }
  if (days <= FRESHNESS_OPTIMAL_DAYS) {
    return { status: 'optimal', label: 'At Peak', detail: `${FRESHNESS_OPTIMAL_DAYS - days} days remaining` };
  }
  return { status: 'past', label: 'Past Peak', detail: `Past peak by ${days - FRESHNESS_OPTIMAL_DAYS} days` };
}

// Espresso extraction standards
const EXTRACTION_TIME_FAST = 22;
const EXTRACTION_TIME_SLIGHTLY_FAST = 25;
const EXTRACTION_TIME_STANDARD_MAX = 30;
const EXTRACTION_TIME_SLIGHTLY_SLOW = 35;
const BREW_RATIO_VERY_LOW = 1.5;
const BREW_RATIO_LOW = 1.8;
const BREW_RATIO_STANDARD_MAX = 2.2;
const BREW_RATIO_HIGH = 2.5;

function getShotAssessment(shot) {
  if (!shot) return null;
  const extractionTime = Number(shot.extractionTime);
  const doseIn = Number(shot.doseIn);
  const yieldOut = Number(shot.yieldOut);
  const hasTime = Number.isFinite(extractionTime);
  const hasRatio = Number.isFinite(doseIn) && Number.isFinite(yieldOut) && doseIn > 0;
  if (!hasTime && !hasRatio) return null;
  const parts = [];
  if (hasTime) {
    const t = extractionTime;
    if (t < EXTRACTION_TIME_FAST) {
      parts.push('Under-extracted \u2192 go finer');
    } else if (t < EXTRACTION_TIME_SLIGHTLY_FAST) {
      parts.push('Slightly under-extracted \u2192 go slightly finer');
    } else if (t > EXTRACTION_TIME_SLIGHTLY_SLOW) {
      parts.push('Over-extracted \u2192 go coarser');
    } else if (t > EXTRACTION_TIME_STANDARD_MAX) {
      parts.push('Slightly over-extracted \u2192 go slightly coarser');
    }
  }
  if (hasRatio) {
    const ratio = yieldOut / doseIn;
    if (ratio < BREW_RATIO_VERY_LOW) {
      parts.push('Yield very low \u2192 pull longer');
    } else if (ratio < BREW_RATIO_LOW) {
      parts.push('Yield slightly low \u2192 pull slightly longer');
    } else if (ratio > BREW_RATIO_HIGH) {
      parts.push('Yield very high \u2192 cut sooner');
    } else if (ratio > BREW_RATIO_STANDARD_MAX) {
      parts.push('Yield slightly high \u2192 cut slightly sooner');
    }
  }
  if (parts.length === 0) {
    return { status: 'good', label: 'Well-extracted' };
  }
  return { status: 'warning', label: parts.join('\n') };
}

// ========================================
// Tests
// ========================================

// --- localDateStr Tests ---
test('localDateStr - returns YYYY-MM-DD from Date object', () => {
  assertEqual(localDateStr(new Date(2026, 0, 15)), '2026-01-15');
});

test('localDateStr - pads single-digit month and day', () => {
  assertEqual(localDateStr(new Date(2026, 1, 5)), '2026-02-05');
});

test('localDateStr - works with no argument (returns today local)', () => {
  const now = new Date();
  const expected = now.getFullYear() + '-' + String(now.getMonth() + 1).padStart(2, '0') + '-' + String(now.getDate()).padStart(2, '0');
  assertEqual(localDateStr(), expected);
});

test('localDateStr - handles late-night dates correctly (no UTC shift)', () => {
  // Simulate 11pm on Feb 5 in local time — should still be Feb 5
  const lateNight = new Date(2026, 1, 5, 23, 0, 0);
  assertEqual(localDateStr(lateNight), '2026-02-05');
});

// --- Date Helper Tests ---
test('isSameDay - same day returns true', () => {
  assert(isSameDay('2026-01-15T08:00:00', '2026-01-15T20:00:00'));
});

test('isSameDay - different days returns false', () => {
  assert(!isSameDay('2026-01-15T08:00:00', '2026-01-16T08:00:00'));
});

test('addDays - adds positive days', () => {
  const result = addDays('2026-01-15', 7);
  assertEqual(result.getDate(), 22);
});

test('addDays - handles month rollover', () => {
  const result = addDays('2026-01-28', 7);
  assertEqual(result.getMonth(), 1); // February
  assertEqual(result.getDate(), 4);
});

test('daysBetween - calculates correctly', () => {
  assertEqual(daysBetween('2026-01-01', '2026-01-08'), 7);
});

test('daysBetween - handles same day', () => {
  assertEqual(daysBetween('2026-01-15', '2026-01-15'), 0);
});

// --- Rating Normalization Tests ---
test('normalizeRating - null returns null', () => {
  assertEqual(normalizeRating(null), null);
});

test('normalizeRating - string "bad" passes through', () => {
  assertEqual(normalizeRating('bad'), 'bad');
});

test('normalizeRating - string "okay" passes through', () => {
  assertEqual(normalizeRating('okay'), 'okay');
});

test('normalizeRating - string "great" passes through', () => {
  assertEqual(normalizeRating('great'), 'great');
});

test('normalizeRating - string "perfect" passes through', () => {
  assertEqual(normalizeRating('perfect'), 'perfect');
});

test('normalizeRating - number 1-2 becomes "bad"', () => {
  assertEqual(normalizeRating(1), 'bad');
  assertEqual(normalizeRating(2), 'bad');
});

test('normalizeRating - number 3 becomes "okay"', () => {
  assertEqual(normalizeRating(3), 'okay');
});

test('normalizeRating - number 4 becomes "great"', () => {
  assertEqual(normalizeRating(4), 'great');
});

test('normalizeRating - number 5 becomes "perfect"', () => {
  assertEqual(normalizeRating(5), 'perfect');
});

test('normalizeRating - invalid string returns null', () => {
  assertEqual(normalizeRating('invalid'), null);
});

// --- Freshness Tests ---
test('getFreshness - no roast date returns unknown', () => {
  const result = getFreshness({ name: 'Test', roastDate: null });
  assertEqual(result.status, 'unknown');
});

test('getFreshness - null bean returns unknown', () => {
  const result = getFreshness(null);
  assertEqual(result.status, 'unknown');
});

test('getFreshness - 0 days is resting', () => {
  const today = new Date().toISOString().slice(0, 10);
  const result = getFreshness({ roastDate: today });
  assertEqual(result.status, 'resting');
});

test('getFreshness - 6 days is resting', () => {
  const sixDaysAgo = addDays(new Date(), -6).toISOString().slice(0, 10);
  const result = getFreshness({ roastDate: sixDaysAgo });
  assertEqual(result.status, 'resting');
});

test('getFreshness - 7 days is optimal', () => {
  const sevenDaysAgo = addDays(new Date(), -7).toISOString().slice(0, 10);
  const result = getFreshness({ roastDate: sevenDaysAgo });
  assertEqual(result.status, 'optimal');
});

test('getFreshness - 21 days is optimal', () => {
  const twentyOneDaysAgo = addDays(new Date(), -21).toISOString().slice(0, 10);
  const result = getFreshness({ roastDate: twentyOneDaysAgo });
  assertEqual(result.status, 'optimal');
});

test('getFreshness - 22 days is past', () => {
  const twentyTwoDaysAgo = addDays(new Date(), -22).toISOString().slice(0, 10);
  const result = getFreshness({ roastDate: twentyTwoDaysAgo });
  assertEqual(result.status, 'past');
});

// --- Bean Data Model Tests ---
test('Bean requires name and roaster', () => {
  const bean = { name: 'Test Bean', roaster: 'Test Roaster' };
  assert(bean.name && bean.roaster);
});

test('Bean with empty name should fail validation', () => {
  const bean = { name: '', roaster: 'Test' };
  const isValid = bean.name.trim() && bean.roaster.trim();
  assert(!isValid);
});

// --- Shot Data Model Tests ---
test('Shot references beanId', () => {
  const shot = { beanId: 'bean-123', grindSize: 5 };
  assert(shot.beanId);
});

test('Shot rating should be normalized', () => {
  const shot = { rating: 4 };
  const normalized = normalizeRating(shot.rating);
  assertEqual(normalized, 'perfect');
});

// --- LocalStorage Mock Tests ---
test('Beans array can be JSON serialized', () => {
  const beans = [
    { id: '1', name: 'Test', roaster: 'Roaster', roastDate: '2026-01-15', isArchived: false }
  ];
  const json = JSON.stringify(beans);
  const parsed = JSON.parse(json);
  assertEqual(parsed[0].name, 'Test');
});

test('Shots array can be JSON serialized', () => {
  const shots = [
    { id: '1', beanId: 'bean-1', grindSize: 5, doseIn: 16, yieldOut: 32, rating: 'perfect', notes: '', createdAt: '2026-01-15T08:00:00Z' }
  ];
  const json = JSON.stringify(shots);
  const parsed = JSON.parse(json);
  assertEqual(parsed[0].grindSize, 5);
});

// --- Sorting Tests ---
test('Beans sort by freshness status', () => {
  const order = { optimal: 0, resting: 1, past: 2, unknown: 3 };
  assert(order.optimal < order.resting);
  assert(order.resting < order.past);
  assert(order.past < order.unknown);
});

test('Archived beans sort after active beans', () => {
  const beans = [
    { name: 'Archived', isArchived: true },
    { name: 'Active', isArchived: false }
  ];
  const sorted = [...beans].sort((a, b) => {
    if (!!a.isArchived !== !!b.isArchived) return a.isArchived ? 1 : -1;
    return 0;
  });
  assertEqual(sorted[0].name, 'Active');
  assertEqual(sorted[1].name, 'Archived');
});

// --- Calendar Logic Tests ---
test('Calendar weeks calculation', () => {
  // February 2026 starts on Sunday
  const year = 2026, month = 1; // February
  const first = new Date(year, month, 1);
  const startDay = first.getDay();
  assertEqual(startDay, 0); // Sunday
});

test('Calendar bar clipping works', () => {
  const monthStart = new Date(2026, 1, 1); // Feb 1
  const monthEnd = new Date(2026, 1, 28); // Feb 28
  const optStart = new Date(2026, 0, 25); // Jan 25
  const optEnd = new Date(2026, 1, 14); // Feb 14

  const clippedStart = optStart < monthStart ? monthStart : optStart;
  const clippedEnd = optEnd > monthEnd ? monthEnd : optEnd;

  assertEqual(clippedStart.getMonth(), 1); // Feb
  assertEqual(clippedEnd.getDate(), 14);
});

// --- hexToRgba Tests ---
function hexToRgba(hex, alpha) {
  const m = hex.match(/^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i);
  if (!m) return hex;
  return `rgba(${parseInt(m[1], 16)},${parseInt(m[2], 16)},${parseInt(m[3], 16)},${alpha})`;
}

test('hexToRgba converts correctly', () => {
  assertEqual(hexToRgba('#C2714F', 0.5), 'rgba(194,113,79,0.5)');
});

test('hexToRgba handles invalid hex', () => {
  assertEqual(hexToRgba('invalid', 0.5), 'invalid');
});

// --- UUID Fallback Test ---
test('crypto.randomUUID exists or fallback works', () => {
  let uuid;
  if (typeof crypto !== 'undefined' && crypto.randomUUID) {
    uuid = crypto.randomUUID();
  } else {
    // Fallback
    uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
      const r = Math.random() * 16 | 0;
      return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
    });
  }
  assert(uuid.length === 36);
  assert(uuid.includes('-'));
});

// --- Stepper Logic Tests ---
test('Stepper clamps to min', () => {
  const min = 1, max = 30;
  const value = -5;
  const clamped = Math.max(min, Math.min(max, value));
  assertEqual(clamped, 1);
});

test('Stepper clamps to max', () => {
  const min = 1, max = 30;
  const value = 100;
  const clamped = Math.max(min, Math.min(max, value));
  assertEqual(clamped, 30);
});

test('Stepper parseInt handles decimals', () => {
  const raw = '16.5';
  const num = parseInt(raw, 10);
  assertEqual(num, 16);
});

// --- Shot Quality Display Tests ---
test('shotQualityLabel capitalizes first letter', () => {
  const r = 'perfect';
  const label = r.charAt(0).toUpperCase() + r.slice(1);
  assertEqual(label, 'Perfect');
});

// --- Shot Assessment Tests ---

// Null/missing data
test('getShotAssessment - null shot returns null', () => {
  assertEqual(getShotAssessment(null), null);
});

test('getShotAssessment - no time and no ratio returns null', () => {
  assertEqual(getShotAssessment({ grindSize: 5 }), null);
});

test('getShotAssessment - doseIn only (no yield) returns null', () => {
  assertEqual(getShotAssessment({ doseIn: 18 }), null);
});

test('getShotAssessment - zero doseIn treated as no ratio', () => {
  assertEqual(getShotAssessment({ doseIn: 0, yieldOut: 36 }), null);
});

// Extraction time — under-extracted
test('getShotAssessment - 18s is under-extracted', () => {
  const r = getShotAssessment({ extractionTime: 18 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('Under-extracted'), 'Expected "Under-extracted"');
  assert(r.label.includes('finer'), 'Expected "finer"');
});

test('getShotAssessment - 21s is under-extracted', () => {
  const r = getShotAssessment({ extractionTime: 21 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('Under-extracted'), 'Expected "Under-extracted"');
});

// Extraction time — slightly under-extracted
test('getShotAssessment - 22s is slightly under-extracted', () => {
  const r = getShotAssessment({ extractionTime: 22 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('Slightly under'), 'Expected "Slightly under"');
  assert(r.label.includes('slightly finer'), 'Expected "slightly finer"');
});

test('getShotAssessment - 24s is slightly under-extracted', () => {
  const r = getShotAssessment({ extractionTime: 24 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('Slightly under'), 'Expected "Slightly under"');
});

// Extraction time — standard range
test('getShotAssessment - 25s is well-extracted', () => {
  const r = getShotAssessment({ extractionTime: 25 });
  assertEqual(r.status, 'good');
  assertEqual(r.label, 'Well-extracted');
});

test('getShotAssessment - 27s is well-extracted', () => {
  const r = getShotAssessment({ extractionTime: 27 });
  assertEqual(r.status, 'good');
  assertEqual(r.label, 'Well-extracted');
});

test('getShotAssessment - 30s is well-extracted', () => {
  const r = getShotAssessment({ extractionTime: 30 });
  assertEqual(r.status, 'good');
  assertEqual(r.label, 'Well-extracted');
});

// Extraction time — slightly over-extracted
test('getShotAssessment - 31s is slightly over-extracted', () => {
  const r = getShotAssessment({ extractionTime: 31 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('Slightly over'), 'Expected "Slightly over"');
  assert(r.label.includes('slightly coarser'), 'Expected "slightly coarser"');
});

test('getShotAssessment - 35s is slightly over-extracted', () => {
  const r = getShotAssessment({ extractionTime: 35 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('Slightly over'), 'Expected "Slightly over"');
});

// Extraction time — over-extracted
test('getShotAssessment - 36s is over-extracted', () => {
  const r = getShotAssessment({ extractionTime: 36 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('Over-extracted'), 'Expected "Over-extracted"');
  assert(r.label.includes('coarser'), 'Expected "coarser"');
});

test('getShotAssessment - 45s is over-extracted', () => {
  const r = getShotAssessment({ extractionTime: 45 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('Over-extracted'), 'Expected "Over-extracted"');
});

// Ratio only — standard
test('getShotAssessment - ratio 2.0 is well-extracted', () => {
  const r = getShotAssessment({ doseIn: 18, yieldOut: 36 });
  assertEqual(r.status, 'good');
  assertEqual(r.label, 'Well-extracted');
});

// Ratio only — low
test('getShotAssessment - ratio 1.3 is very low', () => {
  const r = getShotAssessment({ doseIn: 18, yieldOut: 23.4 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('very low'), 'Expected "very low"');
  assert(r.label.includes('pulling longer'), 'Expected ratio recommendation');
});

test('getShotAssessment - ratio 1.6 is a bit low', () => {
  const r = getShotAssessment({ doseIn: 18, yieldOut: 28.8 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('slightly low'), 'Expected "slightly low"');
  assert(r.label.includes('pulling longer'), 'Expected ratio recommendation');
});

// Ratio only — high
test('getShotAssessment - ratio 2.3 is a bit high', () => {
  const r = getShotAssessment({ doseIn: 18, yieldOut: 41.4 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('slightly high'), 'Expected "slightly high"');
  assert(r.label.includes('cut'), 'Expected ratio recommendation');
});

test('getShotAssessment - ratio 2.8 is very high', () => {
  const r = getShotAssessment({ doseIn: 18, yieldOut: 50.4 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('very high'), 'Expected "very high"');
  assert(r.label.includes('cut'), 'Expected ratio recommendation');
});

// Combined — both off
test('getShotAssessment - fast time + low ratio shows both', () => {
  const r = getShotAssessment({ extractionTime: 18, doseIn: 18, yieldOut: 27 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('finer'), 'Expected grind rec');
  assert(r.label.includes('low'), 'Expected yield note');
});

test('getShotAssessment - slow time + high ratio shows both', () => {
  const r = getShotAssessment({ extractionTime: 40, doseIn: 18, yieldOut: 50 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('coarser'), 'Expected grind rec');
  assert(r.label.includes('high'), 'Expected yield note');
});

// Combined — one off, one in range
test('getShotAssessment - standard time + low ratio shows only ratio', () => {
  const r = getShotAssessment({ extractionTime: 27, doseIn: 18, yieldOut: 28 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('low'), 'Expected yield note');
  assert(!r.label.includes('finer'), 'Should not have grind rec');
});

test('getShotAssessment - fast time + standard ratio shows only time', () => {
  const r = getShotAssessment({ extractionTime: 18, doseIn: 18, yieldOut: 36 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('finer'), 'Expected grind rec');
  assert(!r.label.includes('Yield'), 'Should not have yield note');
});

// Perfect shot with both signals
test('getShotAssessment - 27s with 1:2.0 is well-extracted', () => {
  const r = getShotAssessment({ extractionTime: 27, doseIn: 18, yieldOut: 36 });
  assertEqual(r.status, 'good');
  assertEqual(r.label, 'Well-extracted');
});

// Boundary values for ratio
test('getShotAssessment - ratio exactly 1.5 is a bit low', () => {
  const r = getShotAssessment({ doseIn: 20, yieldOut: 30 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('slightly low'), 'Ratio 1.5 should be "slightly low"');
});

test('getShotAssessment - ratio exactly 1.8 is standard', () => {
  const r = getShotAssessment({ doseIn: 20, yieldOut: 36 });
  assertEqual(r.status, 'good');
});

test('getShotAssessment - ratio exactly 2.2 is standard', () => {
  const r = getShotAssessment({ doseIn: 20, yieldOut: 44 });
  assertEqual(r.status, 'good');
});

test('getShotAssessment - ratio exactly 2.5 is a bit high', () => {
  const r = getShotAssessment({ doseIn: 20, yieldOut: 50 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('slightly high'), 'Ratio 2.5 should be "slightly high"');
});

test('getShotAssessment - NaN extractionTime is ignored', () => {
  assertEqual(getShotAssessment({ extractionTime: NaN }), null);
});

test('getShotAssessment - Infinity extractionTime is ignored', () => {
  assertEqual(getShotAssessment({ extractionTime: Infinity }), null);
});

test('getShotAssessment - non-finite ratio inputs are ignored', () => {
  assertEqual(getShotAssessment({ doseIn: Infinity, yieldOut: 36 }), null);
  assertEqual(getShotAssessment({ doseIn: 18, yieldOut: NaN }), null);
});

test('getShotAssessment - non-numeric extractionTime is ignored when ratio missing', () => {
  assertEqual(getShotAssessment({ extractionTime: 'not-a-number' }), null);
});

// --- Bean Occurrence Counter Tests ---
test('getBeanOccurrence counts correctly', () => {
  const beans = [
    { id: '1', name: 'Test', roaster: 'Roaster', createdAt: '2026-01-01' },
    { id: '2', name: 'Test', roaster: 'Roaster', createdAt: '2026-01-15' },
    { id: '3', name: 'Other', roaster: 'Roaster', createdAt: '2026-01-10' },
  ];

  function getBeanOccurrence(bean, allBeans) {
    const key = (bean.name || '').toLowerCase().trim() + '|' + (bean.roaster || '').toLowerCase().trim();
    const allMatching = allBeans.filter(b => {
      const bKey = (b.name || '').toLowerCase().trim() + '|' + (b.roaster || '').toLowerCase().trim();
      return bKey === key;
    }).sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
    return allMatching.findIndex(b => b.id === bean.id) + 1;
  }

  assertEqual(getBeanOccurrence(beans[0], beans), 1);
  assertEqual(getBeanOccurrence(beans[1], beans), 2);
  assertEqual(getBeanOccurrence(beans[2], beans), 1);
});

// --- Format Tests ---
test('formatRoastDate handles empty', () => {
  function formatRoastDate(dateStr) {
    if (!dateStr) return '';
    const d = new Date(dateStr + 'T00:00:00');
    return 'Roasted ' + d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
  }
  assertEqual(formatRoastDate(''), '');
  assertEqual(formatRoastDate(null), '');
});

// ========================================
// Display Results
// ========================================
function displayResults() {
  const container = document.getElementById('results');
  const summary = document.getElementById('summary');

  let passed = 0, failed = 0;

  results.forEach(r => {
    const div = document.createElement('div');
    div.className = `test ${r.pass ? 'pass' : 'fail'}`;
    div.textContent = `${r.pass ? '✓' : '✗'} ${r.name}`;
    if (!r.pass) {
      div.textContent += ` — ${r.error}`;
      failed++;
    } else {
      passed++;
    }
    container.appendChild(div);
  });

  summary.className = `summary ${failed > 0 ? 'has-fail' : 'all-pass'}`;
  summary.textContent = `${passed} passed, ${failed} failed out of ${results.length} tests`;
}

displayResults();
</script>
</body>
</html>
