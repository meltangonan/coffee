<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Coffee Journal - Tests</title>
<style>
body { font-family: system-ui, sans-serif; max-width: 800px; margin: 40px auto; padding: 0 20px; }
h1 { color: #2C1810; }
.test { padding: 8px 12px; margin: 4px 0; border-radius: 4px; }
.pass { background: #d4edda; color: #155724; }
.fail { background: #f8d7da; color: #721c24; }
.summary { margin-top: 20px; padding: 16px; border-radius: 8px; font-weight: 600; }
.summary.all-pass { background: #d4edda; color: #155724; }
.summary.has-fail { background: #f8d7da; color: #721c24; }
</style>
</head>
<body>
<h1>Coffee Journal - Test Suite</h1>
<div id="results"></div>
<div id="summary"></div>

<script>
// Test utilities
const results = [];
function test(name, fn) {
  try {
    fn();
    results.push({ name, pass: true });
  } catch (e) {
    results.push({ name, pass: false, error: e.message });
  }
}
function assert(condition, message) {
  if (!condition) throw new Error(message || 'Assertion failed');
}
function assertEqual(actual, expected, message) {
  if (actual !== expected) {
    throw new Error(message || `Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);
  }
}
function assertDeepEqual(actual, expected, message) {
  if (JSON.stringify(actual) !== JSON.stringify(expected)) {
    throw new Error(message || `Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);
  }
}

// ========================================
// Helper functions (extracted from app)
// ========================================

function localDateStr(d) {
  if (!d) d = new Date();
  if (typeof d === 'string') d = new Date(d);
  return d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0') + '-' + String(d.getDate()).padStart(2, '0');
}

function isSameDay(d1, d2) {
  const a = new Date(d1), b = new Date(d2);
  return a.getFullYear() === b.getFullYear() && a.getMonth() === b.getMonth() && a.getDate() === b.getDate();
}

function addDays(date, days) {
  const d = new Date(date);
  d.setDate(d.getDate() + days);
  return d;
}

function daysBetween(d1, d2) {
  return Math.floor((new Date(d2) - new Date(d1)) / 86400000);
}

function normalizeRating(r) {
  if (r == null) return null;
  if (r === 'bad' || r === 'okay' || r === 'great' || r === 'perfect') return r;
  if (typeof r === 'number') {
    if (r <= 2) return 'bad';
    if (r === 3) return 'okay';
    if (r === 4) return 'great';
    return 'perfect';
  }
  return null;
}

// Freshness thresholds (should be constants)
const FRESHNESS_RESTING_DAYS = 7;
const FRESHNESS_OPTIMAL_DAYS = 21;

function getFreshness(bean) {
  if (!bean || !bean.roastDate) return { status: 'unknown', label: 'No roast date', detail: '' };
  const days = daysBetween(bean.roastDate, new Date());
  if (days < FRESHNESS_RESTING_DAYS) {
    return { status: 'resting', label: 'Resting', detail: `${FRESHNESS_RESTING_DAYS - days} days until peak` };
  }
  if (days <= FRESHNESS_OPTIMAL_DAYS) {
    return { status: 'optimal', label: 'At Peak', detail: `${FRESHNESS_OPTIMAL_DAYS - days} days remaining` };
  }
  return { status: 'past', label: 'Past Peak', detail: `Past peak by ${days - FRESHNESS_OPTIMAL_DAYS} days` };
}

// Espresso extraction standards
const EXTRACTION_TIME_FAST = 22;
const EXTRACTION_TIME_SLIGHTLY_FAST = 25;
const EXTRACTION_TIME_STANDARD_MAX = 30;
const EXTRACTION_TIME_SLIGHTLY_SLOW = 35;
const BREW_RATIO_VERY_LOW = 1.5;
const BREW_RATIO_LOW = 1.8;
const BREW_RATIO_NEAR_TARGET_LOW = 1.9;
const BREW_RATIO_NEAR_TARGET_HIGH = 2.1;
const FLOW_RATE_CHOKE_MAX = 1.0;

function getShotAssessment(shot) {
  if (!shot) return null;
  const extractionTime = Number(shot.extractionTime);
  const doseIn = Number(shot.doseIn);
  const yieldOut = Number(shot.yieldOut);
  if (!Number.isFinite(extractionTime) || !Number.isFinite(doseIn) || !Number.isFinite(yieldOut)
    || extractionTime <= 0 || doseIn <= 0 || yieldOut <= 0) return null;
  const ratio = yieldOut / doseIn;
  const flowRate = yieldOut / extractionTime;
  // Choking: very low ratio AND low flow rate
  if (ratio < BREW_RATIO_VERY_LOW && flowRate < FLOW_RATE_CHOKE_MAX) {
    return { status: 'warning', label: 'Choked/channeled \u2192 go coarser' };
  }
  // Asymmetric basis: under-yield shots use projection; near/over-target use actual time.
  const projectedTime = (doseIn * 2 / yieldOut) * extractionTime;
  const useProjectedTime = ratio < BREW_RATIO_NEAR_TARGET_LOW;
  const t = useProjectedTime ? projectedTime : extractionTime;
  const belowTarget = ratio < BREW_RATIO_LOW;
  const overNearTarget = ratio > BREW_RATIO_NEAR_TARGET_HIGH;
  const pullLonger = belowTarget && t <= EXTRACTION_TIME_STANDARD_MAX;
  const cutSooner = overNearTarget && t >= EXTRACTION_TIME_SLIGHTLY_FAST;
  if (t < EXTRACTION_TIME_FAST) {
    return { status: 'warning', label: 'Under-extracted \u2192 go finer' + (pullLonger ? '\nPull longer' : '') + (cutSooner ? '\nCut sooner' : '') };
  } else if (t < EXTRACTION_TIME_SLIGHTLY_FAST) {
    return { status: 'warning', label: 'Slightly under-extracted \u2192 go slightly finer' + (pullLonger ? '\nPull longer' : '') + (cutSooner ? '\nCut sooner' : '') };
  } else if (t > EXTRACTION_TIME_SLIGHTLY_SLOW) {
    return { status: 'warning', label: 'Over-extracted \u2192 go coarser' };
  } else if (t > EXTRACTION_TIME_STANDARD_MAX) {
    return { status: 'warning', label: 'Slightly over-extracted \u2192 go slightly coarser' };
  }
  if (belowTarget) {
    return { status: 'warning', label: 'Good flow \u2192 pull longer' };
  }
  if (cutSooner) {
    return { status: 'warning', label: 'Good flow \u2192 cut sooner' };
  }
  return { status: 'good', label: 'Well-extracted' };
}

// ========================================
// Tests
// ========================================

// --- localDateStr Tests ---
test('localDateStr - returns YYYY-MM-DD from Date object', () => {
  assertEqual(localDateStr(new Date(2026, 0, 15)), '2026-01-15');
});

test('localDateStr - pads single-digit month and day', () => {
  assertEqual(localDateStr(new Date(2026, 1, 5)), '2026-02-05');
});

test('localDateStr - works with no argument (returns today local)', () => {
  const now = new Date();
  const expected = now.getFullYear() + '-' + String(now.getMonth() + 1).padStart(2, '0') + '-' + String(now.getDate()).padStart(2, '0');
  assertEqual(localDateStr(), expected);
});

test('localDateStr - handles late-night dates correctly (no UTC shift)', () => {
  // Simulate 11pm on Feb 5 in local time — should still be Feb 5
  const lateNight = new Date(2026, 1, 5, 23, 0, 0);
  assertEqual(localDateStr(lateNight), '2026-02-05');
});

// --- Date Helper Tests ---
test('isSameDay - same day returns true', () => {
  assert(isSameDay('2026-01-15T08:00:00', '2026-01-15T20:00:00'));
});

test('isSameDay - different days returns false', () => {
  assert(!isSameDay('2026-01-15T08:00:00', '2026-01-16T08:00:00'));
});

test('addDays - adds positive days', () => {
  const result = addDays('2026-01-15T00:00:00', 7);
  assertEqual(result.getDate(), 22);
});

test('addDays - handles month rollover', () => {
  const result = addDays('2026-01-28T00:00:00', 7);
  assertEqual(result.getMonth(), 1); // February
  assertEqual(result.getDate(), 4);
});

test('daysBetween - calculates correctly', () => {
  assertEqual(daysBetween('2026-01-01', '2026-01-08'), 7);
});

test('daysBetween - handles same day', () => {
  assertEqual(daysBetween('2026-01-15', '2026-01-15'), 0);
});

// --- Rating Normalization Tests ---
test('normalizeRating - null returns null', () => {
  assertEqual(normalizeRating(null), null);
});

test('normalizeRating - string "bad" passes through', () => {
  assertEqual(normalizeRating('bad'), 'bad');
});

test('normalizeRating - string "okay" passes through', () => {
  assertEqual(normalizeRating('okay'), 'okay');
});

test('normalizeRating - string "great" passes through', () => {
  assertEqual(normalizeRating('great'), 'great');
});

test('normalizeRating - string "perfect" passes through', () => {
  assertEqual(normalizeRating('perfect'), 'perfect');
});

test('normalizeRating - number 1-2 becomes "bad"', () => {
  assertEqual(normalizeRating(1), 'bad');
  assertEqual(normalizeRating(2), 'bad');
});

test('normalizeRating - number 3 becomes "okay"', () => {
  assertEqual(normalizeRating(3), 'okay');
});

test('normalizeRating - number 4 becomes "great"', () => {
  assertEqual(normalizeRating(4), 'great');
});

test('normalizeRating - number 5 becomes "perfect"', () => {
  assertEqual(normalizeRating(5), 'perfect');
});

test('normalizeRating - invalid string returns null', () => {
  assertEqual(normalizeRating('invalid'), null);
});

// --- Freshness Tests ---
test('getFreshness - no roast date returns unknown', () => {
  const result = getFreshness({ name: 'Test', roastDate: null });
  assertEqual(result.status, 'unknown');
});

test('getFreshness - null bean returns unknown', () => {
  const result = getFreshness(null);
  assertEqual(result.status, 'unknown');
});

test('getFreshness - 0 days is resting', () => {
  const today = new Date().toISOString().slice(0, 10);
  const result = getFreshness({ roastDate: today });
  assertEqual(result.status, 'resting');
});

test('getFreshness - 6 days is resting', () => {
  const sixDaysAgo = addDays(new Date(), -6).toISOString().slice(0, 10);
  const result = getFreshness({ roastDate: sixDaysAgo });
  assertEqual(result.status, 'resting');
});

test('getFreshness - 7 days is optimal', () => {
  const sevenDaysAgo = addDays(new Date(), -7).toISOString().slice(0, 10);
  const result = getFreshness({ roastDate: sevenDaysAgo });
  assertEqual(result.status, 'optimal');
});

test('getFreshness - 21 days is optimal', () => {
  const twentyOneDaysAgo = addDays(new Date(), -21).toISOString().slice(0, 10);
  const result = getFreshness({ roastDate: twentyOneDaysAgo });
  assertEqual(result.status, 'optimal');
});

test('getFreshness - 22 days is past', () => {
  const twentyTwoDaysAgo = addDays(new Date(), -22).toISOString().slice(0, 10);
  const result = getFreshness({ roastDate: twentyTwoDaysAgo });
  assertEqual(result.status, 'past');
});

// --- Bean Data Model Tests ---
test('Bean requires name and roaster', () => {
  const bean = { name: 'Test Bean', roaster: 'Test Roaster' };
  assert(bean.name && bean.roaster);
});

test('Bean with empty name should fail validation', () => {
  const bean = { name: '', roaster: 'Test' };
  const isValid = bean.name.trim() && bean.roaster.trim();
  assert(!isValid);
});

// --- Shot Data Model Tests ---
test('Shot references beanId', () => {
  const shot = { beanId: 'bean-123', grindSize: 5 };
  assert(shot.beanId);
});

test('Shot rating should be normalized', () => {
  const shot = { rating: 4 };
  const normalized = normalizeRating(shot.rating);
  assertEqual(normalized, 'great');
});

// --- LocalStorage Mock Tests ---
test('Beans array can be JSON serialized', () => {
  const beans = [
    { id: '1', name: 'Test', roaster: 'Roaster', roastDate: '2026-01-15', isArchived: false }
  ];
  const json = JSON.stringify(beans);
  const parsed = JSON.parse(json);
  assertEqual(parsed[0].name, 'Test');
});

test('Shots array can be JSON serialized', () => {
  const shots = [
    { id: '1', beanId: 'bean-1', grindSize: 5, doseIn: 16, yieldOut: 32, rating: 'perfect', notes: '', createdAt: '2026-01-15T08:00:00Z' }
  ];
  const json = JSON.stringify(shots);
  const parsed = JSON.parse(json);
  assertEqual(parsed[0].grindSize, 5);
});

// --- Sorting Tests ---
test('Beans sort by freshness status', () => {
  const order = { optimal: 0, resting: 1, past: 2, unknown: 3 };
  assert(order.optimal < order.resting);
  assert(order.resting < order.past);
  assert(order.past < order.unknown);
});

test('Archived beans sort after active beans', () => {
  const beans = [
    { name: 'Archived', isArchived: true },
    { name: 'Active', isArchived: false }
  ];
  const sorted = [...beans].sort((a, b) => {
    if (!!a.isArchived !== !!b.isArchived) return a.isArchived ? 1 : -1;
    return 0;
  });
  assertEqual(sorted[0].name, 'Active');
  assertEqual(sorted[1].name, 'Archived');
});

// --- Calendar Logic Tests ---
test('Calendar weeks calculation', () => {
  // February 2026 starts on Sunday
  const year = 2026, month = 1; // February
  const first = new Date(year, month, 1);
  const startDay = first.getDay();
  assertEqual(startDay, 0); // Sunday
});

test('Calendar bar clipping works', () => {
  const monthStart = new Date(2026, 1, 1); // Feb 1
  const monthEnd = new Date(2026, 1, 28); // Feb 28
  const optStart = new Date(2026, 0, 25); // Jan 25
  const optEnd = new Date(2026, 1, 14); // Feb 14

  const clippedStart = optStart < monthStart ? monthStart : optStart;
  const clippedEnd = optEnd > monthEnd ? monthEnd : optEnd;

  assertEqual(clippedStart.getMonth(), 1); // Feb
  assertEqual(clippedEnd.getDate(), 14);
});

// --- hexToRgba Tests ---
function hexToRgba(hex, alpha) {
  const m = hex.match(/^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i);
  if (!m) return hex;
  return `rgba(${parseInt(m[1], 16)},${parseInt(m[2], 16)},${parseInt(m[3], 16)},${alpha})`;
}

test('hexToRgba converts correctly', () => {
  assertEqual(hexToRgba('#C2714F', 0.5), 'rgba(194,113,79,0.5)');
});

test('hexToRgba handles invalid hex', () => {
  assertEqual(hexToRgba('invalid', 0.5), 'invalid');
});

// --- UUID Fallback Test ---
test('crypto.randomUUID exists or fallback works', () => {
  let uuid;
  if (typeof crypto !== 'undefined' && crypto.randomUUID) {
    uuid = crypto.randomUUID();
  } else {
    // Fallback
    uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
      const r = Math.random() * 16 | 0;
      return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
    });
  }
  assert(uuid.length === 36);
  assert(uuid.includes('-'));
});

// --- Stepper Logic Tests ---
test('Stepper clamps to min', () => {
  const min = 1, max = 30;
  const value = -5;
  const clamped = Math.max(min, Math.min(max, value));
  assertEqual(clamped, 1);
});

test('Stepper clamps to max', () => {
  const min = 1, max = 30;
  const value = 100;
  const clamped = Math.max(min, Math.min(max, value));
  assertEqual(clamped, 30);
});

test('Stepper parseInt handles decimals', () => {
  const raw = '16.5';
  const num = parseInt(raw, 10);
  assertEqual(num, 16);
});

// --- Shot Quality Display Tests ---
test('shotQualityLabel capitalizes first letter', () => {
  const r = 'perfect';
  const label = r.charAt(0).toUpperCase() + r.slice(1);
  assertEqual(label, 'Perfect');
});

// --- Shot Assessment Tests ---
// All shots have doseIn, yieldOut, and extractionTime (all required, > 0).
// Tests use 1:2 ratio (18g → 36g) to isolate time boundaries (projection = raw time).

test('getShotAssessment - null shot returns null', () => {
  assertEqual(getShotAssessment(null), null);
});

test('getShotAssessment - missing extractionTime returns null', () => {
  assertEqual(getShotAssessment({ doseIn: 18, yieldOut: 36 }), null);
});

test('getShotAssessment - non-numeric values return null', () => {
  assertEqual(getShotAssessment({ extractionTime: 25, doseIn: 'bad', yieldOut: 36 }), null);
});

test('getShotAssessment - non-positive values return null', () => {
  assertEqual(getShotAssessment({ extractionTime: 0, doseIn: 18, yieldOut: 36 }), null);
  assertEqual(getShotAssessment({ extractionTime: 25, doseIn: -1, yieldOut: 36 }), null);
  assertEqual(getShotAssessment({ extractionTime: 25, doseIn: 18, yieldOut: 0 }), null);
});

// Time boundaries at 1:2 ratio
test('getShotAssessment - 18s is under-extracted', () => {
  const r = getShotAssessment({ extractionTime: 18, doseIn: 18, yieldOut: 36 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('Under-extracted'), 'Expected "Under-extracted"');
  assert(r.label.includes('finer'), 'Expected "finer"');
});

test('getShotAssessment - 21s is under-extracted', () => {
  const r = getShotAssessment({ extractionTime: 21, doseIn: 18, yieldOut: 36 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('Under-extracted'), 'Expected "Under-extracted"');
});

test('getShotAssessment - 22s is slightly under-extracted', () => {
  const r = getShotAssessment({ extractionTime: 22, doseIn: 18, yieldOut: 36 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('Slightly under'), 'Expected "Slightly under"');
  assert(r.label.includes('slightly finer'), 'Expected "slightly finer"');
});

test('getShotAssessment - 24s is slightly under-extracted', () => {
  const r = getShotAssessment({ extractionTime: 24, doseIn: 18, yieldOut: 36 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('Slightly under'), 'Expected "Slightly under"');
});

test('getShotAssessment - 25s is well-extracted', () => {
  const r = getShotAssessment({ extractionTime: 25, doseIn: 18, yieldOut: 36 });
  assertEqual(r.status, 'good');
  assertEqual(r.label, 'Well-extracted');
});

test('getShotAssessment - 27s is well-extracted', () => {
  const r = getShotAssessment({ extractionTime: 27, doseIn: 18, yieldOut: 36 });
  assertEqual(r.status, 'good');
  assertEqual(r.label, 'Well-extracted');
});

test('getShotAssessment - 30s is well-extracted', () => {
  const r = getShotAssessment({ extractionTime: 30, doseIn: 18, yieldOut: 36 });
  assertEqual(r.status, 'good');
  assertEqual(r.label, 'Well-extracted');
});

test('getShotAssessment - 31s is slightly over-extracted', () => {
  const r = getShotAssessment({ extractionTime: 31, doseIn: 18, yieldOut: 36 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('Slightly over'), 'Expected "Slightly over"');
  assert(r.label.includes('slightly coarser'), 'Expected "slightly coarser"');
});

test('getShotAssessment - 35s is slightly over-extracted', () => {
  const r = getShotAssessment({ extractionTime: 35, doseIn: 18, yieldOut: 36 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('Slightly over'), 'Expected "Slightly over"');
});

test('getShotAssessment - 36s is over-extracted', () => {
  const r = getShotAssessment({ extractionTime: 36, doseIn: 18, yieldOut: 36 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('Over-extracted'), 'Expected "Over-extracted"');
  assert(r.label.includes('coarser'), 'Expected "coarser"');
});

test('getShotAssessment - 45s is over-extracted', () => {
  const r = getShotAssessment({ extractionTime: 45, doseIn: 18, yieldOut: 36 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('Over-extracted'), 'Expected "Over-extracted"');
});

// Choking: very low ratio + low flow rate
test('getShotAssessment - 8g in 30s is choked (0.27 g/s)', () => {
  const r = getShotAssessment({ extractionTime: 30, doseIn: 18, yieldOut: 8 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('Choked'), 'Low ratio + low flow = choked');
  assert(!r.label.includes('longer'), 'Should NOT say pull longer');
});

test('getShotAssessment - 20g in 35s is choked (0.57 g/s)', () => {
  const r = getShotAssessment({ extractionTime: 35, doseIn: 18, yieldOut: 20 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('Choked'), 'Low ratio + low flow = choked');
});

// NOT choking: very low ratio but HIGH flow rate (just stopped early)
test('getShotAssessment - 21g in 3s is NOT choked (7 g/s), under-extracted', () => {
  // ratio 1.17, flow 7 g/s → not choking, projected 36g at 5.1s
  const r = getShotAssessment({ extractionTime: 3, doseIn: 18, yieldOut: 21 });
  assertEqual(r.status, 'warning');
  assert(!r.label.includes('Choked'), 'High flow rate should NOT be choked');
  assert(r.label.includes('Under-extracted'), 'Expected under-extracted');
  assert(r.label.includes('finer'), 'Expected go finer');
});

test('getShotAssessment - 20g in 18s is NOT choked (1.11 g/s), uses projection', () => {
  // ratio 1.11, flow 1.11 g/s (above 1.0) → not choking, projected 36g at 32.4s
  const r = getShotAssessment({ extractionTime: 18, doseIn: 18, yieldOut: 20 });
  assertEqual(r.status, 'warning');
  assert(!r.label.includes('Choked'), 'Flow >= 1.0 should not be choked');
});

// Projected time — user stopped early, flow rate is fine
test('getShotAssessment - 30g in 21s projects to ~25s, good flow pull longer', () => {
  // 30g/21s, target 36g → projected 25.2s (standard range)
  const r = getShotAssessment({ extractionTime: 21, doseIn: 18, yieldOut: 30 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('Good flow'), 'Expected good flow');
  assert(r.label.includes('pull longer') || r.label.includes('Pull longer'), 'Expected pull longer');
  assert(!r.label.includes('finer'), 'Should NOT say go finer');
});

test('getShotAssessment - 30g in 20s projects to 24s, slightly under + pull longer', () => {
  // 30g/20s, target 36g → projected 24s (slightly fast)
  const r = getShotAssessment({ extractionTime: 20, doseIn: 18, yieldOut: 30 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('Slightly under'), 'Expected slightly under-extracted');
  assert(r.label.includes('finer'), 'Expected finer');
  assert(r.label.includes('Pull longer'), 'Expected pull longer too');
});

test('getShotAssessment - 30g in 30s projects to ~36s, over-extracted no pull longer', () => {
  // 30g/30s, target 36g → projected 36s (over standard)
  const r = getShotAssessment({ extractionTime: 30, doseIn: 18, yieldOut: 30 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('Over-extracted'), 'Expected over-extracted');
  assert(r.label.includes('coarser'), 'Expected coarser');
  assert(!r.label.includes('longer'), 'Should NOT say pull longer when over-extracted');
});

test('getShotAssessment - 28g in 10s projects to ~13s, under-extracted', () => {
  // 28g/10s, ratio 1.56 (above 1.5), target 36g → projected ~13s (fast)
  const r = getShotAssessment({ extractionTime: 10, doseIn: 18, yieldOut: 28 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('Under-extracted'), 'Expected under-extracted');
  assert(r.label.includes('finer'), 'Expected finer');
});

// At target — projection equals raw time (target/actual = 1)
test('getShotAssessment - 36g in 18s (at target), under-extracted', () => {
  const r = getShotAssessment({ extractionTime: 18, doseIn: 18, yieldOut: 36 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('Under-extracted'), 'Expected under-extracted');
  assert(r.label.includes('finer'), 'Expected finer');
});

// Above target uses actual time (no back-projection)
test('getShotAssessment - 40g in 40s above target, actual-time over-extracted', () => {
  const r = getShotAssessment({ extractionTime: 40, doseIn: 18, yieldOut: 40 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('Over-extracted'), 'Expected over-extracted');
  assert(r.label.includes('coarser'), 'Expected coarser');
});

test('getShotAssessment - 46g in 25s above target, good flow cut sooner', () => {
  const r = getShotAssessment({ extractionTime: 25, doseIn: 18, yieldOut: 46 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('Good flow'), 'Expected good flow');
  assert(r.label.includes('cut sooner') || r.label.includes('Cut sooner'), 'Expected cut sooner');
});

test('getShotAssessment - 40g in 30s above target, good flow cut sooner', () => {
  const r = getShotAssessment({ extractionTime: 30, doseIn: 18, yieldOut: 40 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('Good flow'), 'Expected good flow');
  assert(r.label.includes('cut sooner') || r.label.includes('Cut sooner'), 'Expected cut sooner');
});

test('getShotAssessment - 40g in 25s above target, good flow cut sooner', () => {
  const r = getShotAssessment({ extractionTime: 25, doseIn: 18, yieldOut: 40 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('Good flow'), 'Expected good flow');
  assert(r.label.includes('cut sooner') || r.label.includes('Cut sooner'), 'Expected cut sooner');
});

test('getShotAssessment - 39g in 30s above target, good flow cut sooner', () => {
  const r = getShotAssessment({ extractionTime: 30, doseIn: 18, yieldOut: 39 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('Good flow'), 'Expected good flow');
  assert(r.label.includes('cut sooner') || r.label.includes('Cut sooner'), 'Expected cut sooner');
});

// Asymmetric gate: ratio < 1.9 uses projection, ratio >= 1.9 uses actual time
test('getShotAssessment - ratio 2.06 (37g/18g) with 25s is well-extracted (near-target uses actual time)', () => {
  const r = getShotAssessment({ extractionTime: 25, doseIn: 18, yieldOut: 37 });
  assertEqual(r.status, 'good');
  assertEqual(r.label, 'Well-extracted');
});

test('getShotAssessment - ratio 1.9 boundary uses actual time (not projected)', () => {
  // If projected, this would be slightly over-extracted: (20/19)*30 = 31.6s
  const r = getShotAssessment({ extractionTime: 30, doseIn: 10, yieldOut: 19 });
  assertEqual(r.status, 'good');
  assertEqual(r.label, 'Well-extracted');
});

test('getShotAssessment - ratio 2.1 boundary uses actual time (not projected)', () => {
  // If projected, this would be slightly under-extracted: (20/21)*25 = 23.8s
  const r = getShotAssessment({ extractionTime: 25, doseIn: 10, yieldOut: 21 });
  assertEqual(r.status, 'good');
  assertEqual(r.label, 'Well-extracted');
});

test('getShotAssessment - ratio 2.2 uses actual time and recommends cut sooner', () => {
  const r = getShotAssessment({ extractionTime: 25, doseIn: 10, yieldOut: 22 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('Good flow'), 'Expected good flow');
  assert(r.label.includes('cut sooner') || r.label.includes('Cut sooner'), 'Expected cut sooner');
});

// Standard-ratio but outside near-target gate
test('getShotAssessment - 34g in 15s, ratio 1.89 in standard range, no pull longer', () => {
  // 34g/15s, ratio 1.89 (within 1.8-2.1), projected (36/34)*15 = 15.9s (fast)
  const r = getShotAssessment({ extractionTime: 15, doseIn: 18, yieldOut: 34 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('Under-extracted'), 'Expected under-extracted');
  assert(r.label.includes('finer'), 'Expected finer');
  assert(!r.label.includes('Pull longer'), 'Ratio 1.89 is close enough to target — no pull longer');
});

test('getShotAssessment - 34g in 27s, ratio 1.89 in standard range, well-extracted', () => {
  // 34g/27s, ratio 1.89, projected (36/34)*27 = 28.6s (standard range, ratio in range → well-extracted)
  const r = getShotAssessment({ extractionTime: 27, doseIn: 18, yieldOut: 34 });
  assertEqual(r.status, 'good');
  assertEqual(r.label, 'Well-extracted');
});

test('getShotAssessment - 38g in 27s, ratio 2.11 above near-target, cut sooner', () => {
  // Above near-target gate with standard-time flow -> cut sooner.
  const r = getShotAssessment({ extractionTime: 27, doseIn: 18, yieldOut: 38 });
  assertEqual(r.status, 'warning');
  assert(r.label.includes('Good flow'), 'Expected good flow');
  assert(r.label.includes('cut sooner') || r.label.includes('Cut sooner'), 'Expected cut sooner');
});

// Perfect shot with both signals
test('getShotAssessment - 27s with 1:2.0 is well-extracted', () => {
  const r = getShotAssessment({ extractionTime: 27, doseIn: 18, yieldOut: 36 });
  assertEqual(r.status, 'good');
  assertEqual(r.label, 'Well-extracted');
});

// --- Bean Occurrence Counter Tests ---
test('getBeanOccurrence counts correctly', () => {
  const beans = [
    { id: '1', name: 'Test', roaster: 'Roaster', createdAt: '2026-01-01' },
    { id: '2', name: 'Test', roaster: 'Roaster', createdAt: '2026-01-15' },
    { id: '3', name: 'Other', roaster: 'Roaster', createdAt: '2026-01-10' },
  ];

  function getBeanOccurrence(bean, allBeans) {
    const key = (bean.name || '').toLowerCase().trim() + '|' + (bean.roaster || '').toLowerCase().trim();
    const allMatching = allBeans.filter(b => {
      const bKey = (b.name || '').toLowerCase().trim() + '|' + (b.roaster || '').toLowerCase().trim();
      return bKey === key;
    }).sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
    return allMatching.findIndex(b => b.id === bean.id) + 1;
  }

  assertEqual(getBeanOccurrence(beans[0], beans), 1);
  assertEqual(getBeanOccurrence(beans[1], beans), 2);
  assertEqual(getBeanOccurrence(beans[2], beans), 1);
});

// --- Format Tests ---
test('formatRoastDate handles empty', () => {
  function formatRoastDate(dateStr) {
    if (!dateStr) return '';
    const d = new Date(dateStr + 'T00:00:00');
    return 'Roasted ' + d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
  }
  assertEqual(formatRoastDate(''), '');
  assertEqual(formatRoastDate(null), '');
});

// ========================================
// Display Results
// ========================================
function displayResults() {
  const container = document.getElementById('results');
  const summary = document.getElementById('summary');

  let passed = 0, failed = 0;

  results.forEach(r => {
    const div = document.createElement('div');
    div.className = `test ${r.pass ? 'pass' : 'fail'}`;
    div.textContent = `${r.pass ? '✓' : '✗'} ${r.name}`;
    if (!r.pass) {
      div.textContent += ` — ${r.error}`;
      failed++;
    } else {
      passed++;
    }
    container.appendChild(div);
  });

  summary.className = `summary ${failed > 0 ? 'has-fail' : 'all-pass'}`;
  summary.textContent = `${passed} passed, ${failed} failed out of ${results.length} tests`;
}

displayResults();
</script>
</body>
</html>
